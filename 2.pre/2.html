<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2.2</title>
</head>
<body>

<script src="fx.js"></script>

5. 명령형 습관 지우기 - 만능 reduce? No!

- reduce(복잡한함수, acc, iter) 보다 reduce(함수, map(함수))
<script>
const users = [
  { name: 'AA', age: 35 },
  { name: 'BB', age: 26 },
  { name: 'CC', age: 28 },
  { name: 'DD', age: 34 },
  { name: 'EE', age: 23 }
];
log(reduce((total, u) => total + u.age, 0, users));
log(reduce(add, 0, map(u => u.age, users)));
</script>

- 복잡한 reduce 하나 보다 map + filter + reduce
<script>
log(reduce((total, u) => {
  if (u.age < 30) {
    return total + u.age;
  } else {
    return total;
  }
}, 0, users));

log(reduce((total, u) => u.age < 30 ? total + u.age : total, 0, users));

const sumBy = curry((f, iter) => go(iter, map(f), reduce(add)));

const totalAge = sumBy(u => u.age);

log(totalAge(filter(u => u.age < 30, users)));
</script>

- queryString
<script>
const obj = { search: undefined, type: 'notice', offset: 10, limit: 10 };
const queryString = obj =>
  reduce((qs, [k, v]) => {
    if (qs != '') {
      qs += `&`;
    }
    if (v !== undefined) {
      qs += `${k}=${v}`;
    }
    return qs;
  }, '', Object.entries(obj));

log(queryString(obj));
// type=notice&offset=10&limit=10

// reduce의 보조 함수는 동일한 형의 두 값을 병합하는 함수라고 생각하면 좋습니다.
log(reduce(add, [1, 2, 3, 4, 5]));
log(reduce(Object.assign, [{a: 1}, {b: 2}, {c: 3}]));

log(add(1, 2));
log(Object.assign({a: 1}, {b: 2}));

clear();
// 함수형 사고
// { search: undefined, type: 'notice', offset: 10, limit: 10 }
// [['search', undefined], ['type', 'notice'], ['offset', 10], ...]
// [['type', 'notice'], ['offset', 10], ...]
// ['type=notice', 'offset=10', ...]
// 'type=notice&offset=10...'

const queryString2 = obj => go(
  obj,
  Object.entries,
  filter(([k, v]) => v !== undefined),
  map(([k, v]) => `${k}=${v}`),
  reduce((a, b) => `${a}&${b}`));

log(queryString2(obj));

const join = curry((sep, iter) =>
  reduce((a, b) => `${a}${sep}${b}`, iter));

const queryString3 = obj => go(
  obj,
  Object.entries,
  filter(([k, v]) => v !== undefined),
  map(join('&')),
  join('&'));

log(queryString3(obj));
</script>

- join 함수의 다형성
<script>
log([1, 2, 3].join(';'));

log(join(';', new Set([1, 2, 3])));

log(join(';', function* () {
  yield 10;
  yield 20;
  yield 30;
} ()));

log(join(';', new Map([['a', 1], ['b', 2], ['c', 3]]).keys()));

const iter = new Map([['a', 1], ['b', 2], ['c', 3]]).values();
log(iter.next());
log(iter.next());
log(iter.next());
log(iter.next());
</script>

6. 명령형을 이터러블 프로그래밍으로 전환 2
- while을 range로
<script>
for (const a of filter(a => a % 2, range(1, 6))) log(a);

let i = 1;
while (i < 6) {
  log(i);
  i += 2;
}

for (const a of range(1, 6, 2)) log(a);
</script>
- 효과를 each로 구분하기
<script>
const each = curry((f, iter) => {
  for (const a of iter) f(a);
  return iter;
});

go(range(1, 6, 2), each(log));
</script>

- 추억의 별 그리기
<script>
clear();
// *
// **
// ***
// ****
// *****
go(
  range(1, 6),
  map(n => range(0, n)),
  map(map(_ => '*')),
  map(join('')),
  join('\n'),
  log);
</script>

- 추억의 구구단
<script>
go(
  range(2, 10),
  map(a => go(
    range(1, 10),
    map(b => `${a}x${b}=${a*b}`),
    join('\n')
  )),
  join('\n------\n'),
  log)
clear();
</script>

7. 함수를 설명하는 인자와 리턴 값
- 표기법으로 생각하기
<script>
// f :: a => b
const f = a => a.toUpperCase();
log(f('a'));

// add :: a => b => c
// const add = (a, b) => a + b;

// map :: (a => b) => Iterable a => Iterable b;
log( map(a => a.toUpperCase(), ['a']) );

// reduce :: (a => b => c) => Iterable(a, b) => c
log(reduce(add, [1, 2]));
</script>

- 함수 조합으로 생각하기, 연산자 보다 함수
<script>
// map = takeAll . Lmap;
// map = takeAll(Lmap(f, iter));
// map = pipe(L.map, takeAll);
</script>

- find, some, every
<script>
// const find = function(f, iter) {
//   for (const a of iter) {
//     if (f(a)) return a;
//   }
// };
const identity = a => a;

const find = curry(pipe(
  L.filter,
  L.take(1),
  reduce(identity)));

log(find(a => a > 3, [1, 2, 3, 4, 5, 6]));

const some = curry(pipe(
  L.filter,
  take(1),
  _ => _.length,
  Boolean
));
log(some(a => a > 3, [1, 2, 3, 4, 5, 6]));

L.takeUntil = curry(function* (f, iter) {
  for (const a of iter) {
    yield a;
    if (f(a)) break;
  }
});

// const some2 = curry((f, iter) =>
//   reduce((a, b) => Boolean(a || b), false,
//     L.takeUntil(identity,
//       L.map(f, iter))));

const some2 = curry(pipe(
  L.map,
  L.takeUntil(a => a),
  reduce((a, b) => a || b),
  (a = false) => Boolean(a)
));

log(some2(a => a > 3, [1, 2, 3, 4, 5, 6]));
log(some2(a => a > 7, [1, 2, 3, 4, 5, 6]));
log(some2(a => a > 7, []));

const not = a => !a;
L.reject = (f, iter) => L.filter(pipe(f, not), iter);

const every = curry((f, iter) => go(
  L.reject(f, iter),
  take(1),
  _ => _.length,
  not
));
log(every(a => a < 5, [1, 2, 3, 4, 5, 6]));

const every2 = curry(pipe(
  L.map,
  L.takeUntil(not),
  reduce((a, b) => a && b),
  (a = false) => Boolean(a)
));

log(every2(a => a < 5, [1, 2, 3, 4, 5, 6]));
log(every2(a => a < 15, [1, 2, 3, 4, 5, 6]));
log(every2(a => a < 15, []));
</script>
- filter + take + reduce(identity)
- 지연 평가를 통한 최적화

</body>
</html>