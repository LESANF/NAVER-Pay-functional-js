<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2.3</title>
</head>
<body>

<script src="fx.js"></script>

8. 객체를 이터러블 프로그래밍으로 다루기
- values
- entries
- keys
- 어떤 값이든 이터러블 프로그래밍으로 다루기 - 제너레이터의 다형성
- fromEntries
- mapObject
- pick
- indexBy
- indexBy된 값을 filter하기

9. 객체지향과 함께 사용하기
- Map, Set, NodeList
- Model, Collection 클래스 만들어서 이터러블 프로토콜 지원하기
<script>
class Model {
  constructor(attrs = {}) {
    this._attrs = attrs;
  }
  set(k, v) {
    this._attrs[k] = v;
    return this;
  }
  get(k) {
    return this._attrs[k];
  }
}
class Collection {
  constructor(models = []) {
    this._models = models;
  }
  add(model) {
    this._models.push(model);
    return this;
  }
  at(idx) {
    return this._models[idx];
  }
  [Symbol.iterator]() {
    return this._models[Symbol.iterator]();
  }
}

const method = f => function() { return f(this); };

class Products extends Collection {
  selectedProducts() {
    return new Products(filter(p => p.get('is_selected'), this));
  }
}

const products = new Products([
  new Model({ price: 1000}),
  new Model({ price: 2000}),
  new Model({ price: 1000})
]);

log(reduce(add, L.map(p => p.get('price'), products)));

</script>
- Product, Products - 메서드를 함수형으로 구현하기

</body>
</html>