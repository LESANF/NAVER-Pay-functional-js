<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>1회</title>
</head>
<body>

<script>
const {log, clear} = console;
</script>

1. 들어가며

# 이터러블 프로토콜을 익혀야 하는 이유

## ES6+의 표준 프로토콜
- for...of 문은 이터러블을 순회한다.
<script type="module">
  for (const a of [1, 2, 3]) log(a);
  // 1
  // 2
  // 3
</script>

- 이터러블은 전개 연산자를 통해 펼칠 수 있다.
<script>
  log([...[1, 2], ...[3, 4]]);
  // [1, 2, 3, 4]
</script>

- [] 를 통한 구조분해는 이터러블에 사용한다.
<script>
  const [first, second] = [1, 2];
  log(first); // 1
  log(second); // 2
</script>

- 나머지 연산자도 이터러블에 사용한다.
<script>
  const [head, ...tail] = [1, 2, 3];
  log(head); // 1
  log(tail); // [2, 3]
</script>

- 이터러블은 [Symbol.iterator]()를 통해 이터레이터를 반환한다.
- 제너레이터는 이터레이터를 반환한다.
- 이터레이터는 곧 이터러블이다. (well-formed)
- 그러므로 이터레이터/제너레이터는 자바스크립트의 연산자와 구문과 함께 동작한다.
<script>
  function* generator() {
    yield 10;
    yield 20;
    yield 30;
  }

  const iterator = generator();
  log(iterator.next()); // {value: 10, done: false}
  log(iterator.next()); // {value: 20, done: false}
  log(iterator.next()); // {value: 30, done: false}
  log(iterator.next()); // {done: true}

  const [h, ...t] = generator();
  log(h); // 10
  log(t); // [20, 30]
</script>

- 이런 규약을 통칭해 이터러블 프로토콜이라고 하며 이것은 ES6에서 매우 중요한 중심에 있다.
- ES6+ 에서도 이런 규약을 사용하거나 이 컨셉과 함께하는 규약들이 만들어지고 있다.

## 프로그래밍 패러다임
 - 이터러블/이터레이터/제너레이터는 코드를 값으로 다룰 수 있도록 하는 도구다.
<script>
  function myCode1(l) {
    if (l > 0) log('a');
    if (l > 1) log('b'.toUpperCase());
    if (l > 2) log('c');
    if (l > 3) log('d'.toUpperCase());
  }
  myCode1(2);
  // a
  // b

  function* myCode2() {
    yield 'a';
    yield 'b'.toUpperCase();
    yield 'c';
    yield 'd'.toUpperCase();
  }

  function* take(l, iter) {
    let i = -1;
    while (++i < l) {
      const {value, done} = iter.next();
      if (done) break;
      yield value;
    }
  }

  function each(f, iter) {
    for (const a of iter) f(a);
  }

  each(log, take(1, myCode2()));
  // a
  each(log, take(3, myCode2()));
  // a
  // B
  // c
</script>

- 코드를 값으로 다루는 것은 리습/메타프로그래밍에서의 핵심적인 기법이다.
- 자바스크립트는 이제 공식적으로 코드, 로직, 상태, 에러를 '값'으로 다룰 수 있게 되었다.
- 여기서 말하는 코드, 로직, 상태, 에러에는 비동기적인 것도 포함된다.
- 함수와 코드를 값으로 다루는 프로그래밍 기법은 또 하나의 프로그래밍 패러다임이다.
- 이터러블 프로토콜을 잘 다룬다는 것은 새로운 프로그래밍 패러다임을 익히는 것과 같다.
- 새로운 프로그래밍 패러다임을 익히는 것은 언어를 응용하는 사고를 확장하는 것이다.
- 언어에 대한 응용력이 좋아지면 문제 해결력, 생산성, 안정성이 좋아진다.
- 문제 해결, 생산성, 안정성은 성공적인 프로그래밍의 핵심적인 지표다.

## 조합성, 재사용성
- 코드가 값으로 다뤄 질수 있다는 것은 그 코드가 어떤 '규약'을 지키고 있다는 것이다.
- 값으로 다룰 수 있도록 규약이 지켜진 코드는 재사용성이 높다.
- 규약이 지켜진 코드는 다른 코드와의 조합성이 높다.
- 규약이 지켜진 코드는 협업을 용이하게 한다.
- 이 규약이 언어의 규약과 일치할 수록 언어와 여러 도구의 도움을 받기 용이하다.

## 응용력
- 추상화가 잘 된 규약은 응용력이 높다.
- 이터러블은 값을 계산하여 세분화해나가면서도 이터러블인 상태를 유지하도록 하여
  추상화 수준을 동일하게 유지하는 아이디어를 가지고 있다.
<script>
  const iter1 = myCode2();
  log(iter1.next()); // {value: "a", done: false}

  const iter2 = take(1, iter1);
  log(iter2.next()); // {value: "B", done: false}
  log(iter2.next()); // {done: true}
</script>

- 추상화 단계가 유지되면 여전히 동일한 응용력을 가질 수 있다.
- 일반화가 많이 된 규약은 특정 상황에만 잘 대응될 가능성이 높다.
- 소프트웨어의 복잡성이 증가할 수록 특정 상황에 특화된 패러다임보다는
  유연성과 생산성을 함께 높일 수 있는 패러다임이 유리하다.

## 결론
- '이터러블 프로그래밍'이라는 규약을 중심에 두고 팀 작업을 하게 되면,
  구성원 간에 같은 관점을 갖게하여 소통을 용이하게 하고,
  생산성, 조합성, 안정성, 코드 품질 관리의 객관성을 높일 수 있게 한다.
- 팀에서 패러다임을 공유하고 그 패러다임이 팀에서 성숙 된다면
  그 가치는 단순히 문법이나 코딩 컨벤션을 지키는 것과는 비교할 수 없을 만큼 특별하다.
- 명령형 코드는 서로의 코드를 이해하기 어렵지만
  함수형 코드는 이해하기 쉬울 뿐 아니라 '코드를 응용(Applicative)' 할 수 있게 한다.

2. ES6+ 기본기

# 이터러블
- 이터레이터를 리턴하는 [Symbol.iterator]() 를 가진 값
<script type="module">
  const arr = [1, 2, 3];
  for (const a of arr) log(a);
  for (const a of arr) log(a);
  arr[Symbol.iterator] = null;
  for (const a of arr) log(a);
</script>

# 이터레이터
- { value, done } 객체를 리턴하는 next() 를 가진 값
<script>
</script>

# 제너레이터
- 이터레이터를 만드는 함수
- yield 와 return 을 통해 이터레이터의 next()의 결과를 생성

<script>
</script>

# well-formed 이터러블
- iterator1에게 iterator1[Symbol.iterator]() 메서드가 있다.
- iterator1[Symbol.iterator]() 를 실행했을 때 iterator1를 리턴한다.
- 만일 iterable1[Symbol.iterator]()를 실행했을 때 iterator1을 리턴한다면
- iterable1 은 well-formed 이터러블이다.

<script>
</script>

# 전개, 나머지, 구조 분해

<script>
</script>

3. 함수
# 일급 함수
# 고차 함수

4. map, filter
# map
# filter

5. 이터러블 프로토콜로 다시 만들기
# map
# filter
# 이터러블 프로토콜의 다형성

6. 이터러블 프로토콜로 다시 만들기 2
# L.map
# L.filter

7. take 와 range
# take
# range
# L.take
# L.range

8. 지연 평가와 제너레이터
# L.map
# L.filter
# L.range
# take, 동작 순서

</body>
</html>